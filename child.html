<!DOCTYPE html>

<html lang="en">
	<head>
		<title>Child</title>

		<!-- 
		A Christmas Musical for VR

		uses three.js, Mozilla's webVR basics, and Andrea Hawksley's webVR navigation.
		 -->

		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000;
				color: #fff;
				margin: 0px;
				padding: 0;
				overflow: hidden;
			}
		</style>
	</head>

	<body>
		<audio id='music' src="media/child1.ogg" autoplay=true loop=true/>
		<audio id='music2' src="media/child2.ogg" autoplay=true loop=true/> 
	</body>

	<!--
	three.js 3d library
	-->
	<script src="js/three.min.js"></script>

	<!--
	library for fast quaternion rotation
	-->
	<script src="lib/gl-matrix.js"></script>

	<!--
	VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object. VRControlsPlus adds rotation and movement controls that move and rotate the world relative to the camera, using arrow keys, WASD, plus interaction controls.
	 -->
	<script src="js/VRControlsPlus.js"></script>

	<!--
	VREffect.js handles stereo camera setup and rendering.
	-->
	<script src="js/VREffect.js"></script>


	<script>
		/*
		Setup three.js WebGL renderer
		*/
		var renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setClearColor( 0x000000, 1 );
		/*
		Append the canvas element created by the renderer to document body element.
		*/
		document.body.appendChild( renderer.domElement );
		/*
		Create a three.js scene
		*/
		var scene = new THREE.Scene();
		/*
		Create a three.js camera
		*/
		var camera = new THREE.PerspectiveCamera( 110, window.innerWidth / window.innerHeight, 1, 10000 );
		/*
		Apply VR headset positional data to camera.
		*/
		var controls = new THREE.VRControls( camera );
		/*
		Apply VR stereo rendering to renderer
		*/
		var effect = new THREE.VREffect( renderer );
		effect.setSize( window.innerWidth, window.innerHeight );

		/*
		define interaction variables
		*/
		var mouseY = 1;
		var mouseX = 1;
		var clicky = 0;


		var t = 0;
		var snowFloor = -40;
		var foundLight = 0;
		var lightPlace = new THREE.Vector3(Math.r)
		var music = document.querySelector('#music');
  		var music2 = document.querySelector('#music2');	
  		var wanderTime = 0;
  		var newPos = new THREE.Vector3(0,0,0);

		camera.position.y = -30;
  		music2.volume = 0;
  		
		//make particles
		var particles = new THREE.Geometry();
		var partCount = 1500;

		for (var p = 0; p<partCount; p++){
			var part = new THREE.Vector3(
		      	120*Math.random() - 80,
		      	95*Math.random() + snowFloor,
		      	120*Math.random() - 80
				);
			part.velocity = new THREE.Vector3(
				Math.random()/10,
				-Math.random()*0.2,
				Math.random()*.09);
			particles.vertices.push(part);
		}

		var particleSystem = new THREE.PointCloud(
			particles,
			new THREE.PointCloudMaterial({
				color: 0x333366,
				size: 1.5,
				map: THREE.ImageUtils.loadTexture("media/starflake.png"),
				blending: THREE.AdditiveBlending,
				transparent: true
				}));

		particleSystem.sortParticles = true;
		scene.add(particleSystem);


		//dodecahedra

		var dodecArray = [];
		var dodecCount = 120;
		var dodecGeom = new THREE.DodecahedronGeometry(1);
		var dodecMat = new THREE.MeshLambertMaterial();
		var size = 0;

		for (var p = 0; p<dodecCount; p++){
			dodecArray[p] = new THREE.Mesh(dodecGeom, dodecMat);
			dodecArray[p].position.set(
				Math.random()*100 -50, 
				Math.random()*18 -44,
				Math.random()*100 -50);
			if (dodecArray[p].position.distanceTo(camera.position) < 10){
				dodecArray[p].position.z += 20;
			}
			size = Math.random()*7;
			dodecArray[p].scale.set(size, size, size);
			scene.add(dodecArray[p]);
		}

		//sign

		var infoText = THREE.ImageUtils.loadTexture( "media/arrows-sound.png" );
		var signMat = new THREE.MeshLambertMaterial({map: infoText, color: 0xffffff});
		var sign = new THREE.Mesh(dodecGeom, signMat);

		sign.position.set(-0.2, -31, -1.5);
		sign.rotation.y = 2;
		scene.add(sign);

		//icosahedra

		var icosArray = [];
		var icosCount = 20;
		var icosGeom = new THREE.IcosahedronGeometry(1);
		var icosMat = new THREE.MeshLambertMaterial({wireframe:true});

		for (var p = 0; p<icosCount; p++){
			icosArray[p] = new THREE.Mesh(icosGeom, icosMat);
			icosArray[p].position.set(
				Math.random()*100 -50, 
				Math.random()*10 -30, 
				Math.random()*100 -50);
			size = Math.random()*20;
			icosArray[p].scale.set(size, size, size);
			scene.add(icosArray[p]);
		}

		//create light
		var light = new THREE.SpotLight( 0xffffff, .8, 800);
		light.position.set( -50,20,.1);
		light.castShadow = true; 
		scene.add( light );

		var light2 = new THREE.SpotLight( 0xffffff, .4, 600);
		light2.position.set( 30,10,40);
		light2.castShadow = true; 
		scene.add( light2 );

		var light3 = new THREE.SpotLight( 0xffffff, .2, 500);
		light3.position.set( -10,15,20);
		light3.castShadow = true; 
		scene.add( light3 );

		var goldLight = new THREE.PointLight( 0xffff00, .6, 10);
		goldLight.position.set(
				Math.random()*100 -50, 
				Math.random()*18 -44,
				Math.random()*100 -50);
			if (goldLight.position.distanceTo(camera.position) < 10){
				goldLight.position.z += 20;
			}
		goldLight.castShadow = false; 
		scene.add( goldLight );	

		/*
		Request animation frame loop function
		*/
		function animate() {

			t += .01;

			light.position.x += Math.sin(t); //roving white lights
			light.position.z += Math.cos(t);
			light2.position.x += Math.sin(t)*1.5;
			light2.position.z += Math.cos(t)*1.5;
			light3.position.x += Math.sin(t)*2.5;
			light3.position.z += Math.cos(t)*2.5;
			
			//light gamification
			if ( foundLight == 0){ //haven't found the gold light
				goldLight.intensity += Math.sin(t)/200;
				goldLight.distance += .001;
				music2.volume = (99*music2.volume + .00001)/100;
				music.volume = (99*music.volume + .999)/100;
				if ( goldLight.position.distanceTo(camera.position) < goldLight.distance
					){
					foundLight = 1;
				}
			} else if (foundLight == 1){ //found the light, make it glow
				music.volume = (99*music.volume + .000001)/100;
				music2.volume = (99*music2.volume + .999)/100;
				goldLight.intensity += .005;
				goldLight.distance += .5;
				if (goldLight.intensity > 2){
					goldLight.distance = (19 * goldLight.distance + 12) / 20;
					if (goldLight.intensity > 3){
						newPos.set(
							Math.random()*100 -50, 
							Math.random()*18 -44,
							Math.random()*100 -50);
						foundLight = 2;
					}
				}
			} else if (foundLight == 2){ //light starts wandering
				goldLight.distance = 12;
				goldLight.position.x += Math.sin(t/2)*Math.random()/4;
				goldLight.position.z += Math.cos(t/2)*Math.random()/4;
				music2.volume = Math.min(1, goldLight.position.distanceTo(camera.position));
				wanderTime += .01
				if (wanderTime > 10){//light settles into new random place
					goldLight.position.x = (999*goldLight.position.x + newPos.x)/1000;
					goldLight.position.z = (999*goldLight.position.z + newPos.z)/1000;
					if (goldLight.position.distanceTo(camera.position) < 10){
						goldLight.position.z += 20;
					}
				}
				if (wanderTime > 15){//reset light
					goldLight.distance = 10;
					goldLight.intensity = .6;
					foundLight = 0;
					wanderTime = 0;
				}
			}

			if (camera.position.y < -25){
				snowFloor = camera.position.y - 10;
			} else {
				snowFloor = -35;
			}
	
			for (var p = 0; p<partCount; p++) {

			    // check if we need to reset particles
			    if (particles.vertices[p].y < snowFloor) {
			      particles.vertices[p].set(
			      	120*Math.random() - 80,
			      	snowFloor + 95,
			      	120*Math.random() - 80);
			      particles.vertices[p].velocity.y = -Math.random();
			    } 

		       	particles.vertices[p].velocity.x = Math.random()/10;
		       	particles.vertices[p].velocity.y = -Math.random()*.2;
		       	particles.vertices[p].velocity.z = Math.random()/10; 
		       	particleSystem.material.color.setRGB(1,1,1);

			    particles.vertices[p].y += particles.vertices[p].velocity.y;
			    particles.vertices[p].z += particles.vertices[p].velocity.z;
			    particles.vertices[p].x += particles.vertices[p].velocity.x;
		 	 }

			/*
			Update VR headset position and apply to camera.
			*/
			controls.update();
			/*
			Render the scene through the VREffect.
			*/
			effect.render( scene, camera );
			requestAnimationFrame( animate );
		}
		/*
		Kick off animation loop
		*/
		animate();

		//listen for mouse movement to get mouseX and mouseY

		document.body.addEventListener( 'mousemove', function (event) {
		 	mouseY = event.clientY;
		 	mouseX = event.clientX;
		});

		//listen for click

		document.body.addEventListener( 'click', function(){
			clicky = (clicky + 1) % 6;
		})
		/*
		Listen for double click event to enter full-screen VR mode
		*/
		document.body.addEventListener( 'dblclick', function() {
			effect.setFullScreen( true );
		});
		/*
		Listen for keyboard events 
		*/
		function onkey(event) {
	    event.preventDefault();

	    if (event.keyCode == 90) { // z
	    	controls.zeroSensor(); //zero rotation
	    } else if (event.keyCode == 70 || event.keyCode == 13) { //f or enter
	    	effect.setFullScreen(true) //fullscreen else if (event.keyCode == 80) {//p
	  		
	  	} else if (event.keyCode == 32 || event.keyCode == 80) { //space or p
	  		if (music.paused){
	  			music.play();
	  			music2.play();
	  		} else{
	  			music.pause();	
	  			music2.pause();
	  		}
	  	}

	  };

	    window.addEventListener("keydown", onkey, true);

		document.addEventListener('keydown', function(event) { key(event, 1); }, false);
		document.addEventListener('keyup', function(event) { key(event, -1); }, false);

		/*
		Handle window resizes
		*/
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			effect.setSize( window.innerWidth, window.innerHeight );
		}
		window.addEventListener( 'resize', onWindowResize, false );
	</script>
</html>