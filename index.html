<!DOCTYPE html>

<html lang="en">
	<head>
		<title>playing with webVR</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000;
				color: #fff;
				margin: 0px;
				padding: 0;
				overflow: hidden;
			}
		</style>
	</head>

	<body>
		<iframe id="frame" allowFullScreen=true style="display:none"></iframe>
	</body>

	<!--
	three.js 3d library
	-->
	<script src="js/three.min.js"></script>

	<!--rotating quaternions library-->
	<script src="lib/gl-matrix.js"></script>

	<!--
	VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
	 -->
	<script src="js/VRControls.js"></script>

	<!--
	VREffect.js handles stereo camera setup and rendering.
	-->
	<script src="js/VREffect.js"></script>

	<script>
		/*
		Setup three.js WebGL renderer
		*/
		var renderer = new THREE.WebGLRenderer( { antialias: true } );

		/*
		Append the canvas element created by the renderer to document body element.
		*/
		document.body.appendChild( renderer.domElement );

		/*
		Create a three.js scene
		*/
		var scene = new THREE.Scene();

		/*
		Create a three.js camera
		*/
		var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );

		/*
		Apply VR headset positional data to camera.
		*/
		var controls = new THREE.VRControls( camera );

		/*
		Apply VR stereo rendering to renderer
		*/
		var effect = new THREE.VREffect( renderer );
		effect.setSize( window.innerWidth, window.innerHeight );

		/*
		Create 3d objects
		*/


		var geometry = new THREE.BoxGeometry( 15, 15, 15 );
		var spheregeom = new THREE.SphereGeometry( 10, 10, 4 );
		var tetgeom = new THREE.TetrahedronGeometry(10);

		var material = new THREE.MeshBasicMaterial({color:0xffff00, wireframe: true});
		var cubematerial = new THREE.MeshBasicMaterial( {color: 0Xff0000, wireframe: true})
		var tetred = new THREE.MeshBasicMaterial( {color: 0x880044} );
		var tetblue = new THREE.MeshBasicMaterial( {color: 0xff3300} );
		var tetgreen = new THREE.MeshBasicMaterial( {color: 0xff5077} );
		var tetyellow = new THREE.MeshBasicMaterial( {color: 0x332222} );
		var tetcyan = new THREE.MeshBasicMaterial( {color: 0x004444} );

		var cube = new THREE.Mesh( geometry, cubematerial ); //spinnycubes
		var cube2 = new THREE.Mesh( geometry, cubematerial );
		var cube3 = new THREE.Mesh( geometry, cubematerial );
		var cube4 = new THREE.Mesh( geometry, cubematerial );
		var cube5 = new THREE.Mesh( geometry, cubematerial );

		var sphere = new THREE.Mesh( spheregeom, material ); //top sphere



		//create FIT:
		var tet = new THREE.Mesh( tetgeom, tetred );
		var tet2 = new THREE.Mesh( tetgeom, tetblue );
		var tet3 = new THREE.Mesh( tetgeom, tetgreen );
		var tet4 = new THREE.Mesh( tetgeom, tetcyan );
		var tet5 = new THREE.Mesh( tetgeom, tetyellow );

		var FIT = new THREE.Object3D();
		FIT.position.z = -20;
		FIT.position.x = -15;
		FIT.add(tet, tet2, tet3, tet4, tet5);
		scene.add(FIT);

		var t = ((1 + Math.sqrt(5))/2);
		var fturn = 6.283/5;
		var axis = new THREE.Vector3( t, 1, 0 );
		var incy = 0;
		axis.normalize();

		tet.rotateOnAxis (axis, 0);
		tet2.rotateOnAxis (axis, fturn);
		tet3.rotateOnAxis (axis, 2*fturn);
		tet4.rotateOnAxis (axis, 3*fturn);
		tet5.rotateOnAxis (axis, 4*fturn);

		//create four bouncing boxes:
		var Things = [];
		var boxWave = 0;
		var thingpos = 0;
		  for (var i = 0; i < 4; i++) {
		    Things[i] = new THREE.Mesh(
		      new THREE.BoxGeometry(10,10,10,10,10,10),
		     	new THREE.MeshBasicMaterial({color:'blue'}));
		  scene.add(Things[i]);
		  thingpos += -10;
		  Things[i].position.x = thingpos;
		  Things[i].position.y = -20;
		  Things[i].position.z = 40;
		  }
		/*

		Position mesh
		*/

		cube2.position.x = 20;
		cube3.position.x = 20;
		cube4.position.x = 20;
		cube5.position.x = 20;

		sphere.position.y = 30;
		sphere.position.z = -10;
		/*
		Add cube mesh to your three.js scene
		*/

		scene.add( cube2 );
		scene.add( cube3 );
		scene.add( cube4 );
		scene.add( cube5 );

		scene.add( sphere );
		/*
		Request animation frame loop function
		*/
		function animate() {
			/*
			Apply rotation to cube mesh
			*/

			cube2.rotation.x += 0.005;
			cube2.rotation.z += 0.007;

			cube3.rotation.x += 0.006;
			cube3.rotation.z += 0.008;

			cube4.rotation.x += 0.007;
			cube4.rotation.z += 0.009;

			cube5.rotation.x += 0.008;
			cube5.rotation.z += 0.01;

			sphere.rotation.x += 0.1;
			sphere.rotation.y += 0.04;

			FIT.rotation.y += .006;
			FIT.rotation.x += .002;


		boxWave += .1
		  for (var i = 0; i < 4; i++) {
		    Things[i].position.y += Math.sin(boxWave*(1/(i+2)));
		  }


			/*
			Update VR headset position and apply to camera.
			*/
			controls.update();

			/*
			Render the scene through the VREffect.
			*/
			effect.render( scene, camera );

			requestAnimationFrame( animate );

		}

		/*
		Kick off animation loop
		*/
		animate();

		//logs camera pos when h is pressed
		function rotest(){
			console.log(camera.rotation.x, camera.rotation.y, camera.rotation.z);
		}

		//linking function
		function link(){
			if((camera.rotation.x > 1.2) && (camera.rotation.x < 1.8) && (camera.rotation.y > -0.4) && (camera.rotation.y < .4)){
			   window.location="http://vihart.github.io/webVR-playing-with/spindex.html";
			 } else if ((camera.rotation.x < 3) && (camera.rotation.y < -1)){
				window.location= "http://vihart.github.io/webVR-playing-with/inside.html";
			} else if ((camera.rotation.x > -1) && (camera.rotation.x < 0) && (camera.rotation.y > .3) && (camera.rotation.y < .7)) {
				window.location= "http://vihart.github.io/webVR-playing-with/compound.html";
			} else if (((camera.rotation.x > 2.3) || (camera.rotation.x < -2.8)) && (camera.rotation.y > 0) && (camera.rotation.y < .7)){
				window.location= "http://vihart.github.io/webVR-playing-with/wave.html";
			} else {
				false
			}

		}
		
		var frame = document.getElementById('frame');
		frame.height = window.innerHeight;
		frame.width = window.innerWidth;

		function fullscreen() {
			frame.style.display = "block";
			frame.src = "http://vihart.github.io/webVR-playing-with/frame.html";
			frame.focus();

		  if (frame.mozRequestFullScreen) {
		    frame.mozRequestFullScreen({ vrDisplay: effect._vrHMD }); // Firefox
		    frame.focus();
		  } else if (frame.webkitRequestFullscreen) {
		    frame.webkitRequestFullscreen({ vrDisplay: effect._vrHMD }); // Chrome and Safari
		    frame.focus();
		  } else if (frame.requestFullScreen){
		    frame.requestFullscreen();
		    frame.focus();
		  }
		}

		/*
		Listen for keyboard events zero positional sensor on appropriate keypress.
		*/
		function onkey(event) {
	    event.preventDefault();

	    if (event.keyCode == 90) { // z
	    	controls.zeroSensor(); //zero rotation
	    } else if (event.keyCode == 70 || event.keyCode == 13) { //f or enter
	    	fullscreen();
	    	// effect.setFullScreen(true) //fullscreen
	    } else if (event.keyCode == 32) {//space
	  		link();
	  	// } else if (event.keyCode == 37){ //right arrow
	  	// 	camera.rotation.x += .1; //do not know how to do this thing
	  	// } else if (event.keyCode == 39){ //left arrow
	  	// 	camera.rotation.x += -.1;
	  	} else if (event.keyCode == 72) {//h
	  		rotest();
	  		}
	  };

	  window.addEventListener("keydown", onkey, true);


	  //hold down keys to do rotations and stuff
		function key(event, sign) {
		  var control = controls.manualControls[String.fromCharCode(event.keyCode).toLowerCase()];
		  if (!control)
		    return;
		  if (sign === 1 && control.active || sign === -1 && !control.active)
		    return;
		  control.active = (sign === 1);
		  controls.manualRotateRate[control.index] += sign * control.sign;
		}
		document.addEventListener('keydown', function(event) { key(event, 1); }, false);
		document.addEventListener('keyup', function(event) { key(event, -1); }, false);

		/*
		Handle window resizes
		*/
		function onWindowResize() {
			frame.height = window.innerHeight;
			frame.width = window.innerWidth;

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			effect.setSize( window.innerWidth, window.innerHeight );
		}

		window.addEventListener( 'resize', onWindowResize, false );

	</script>
</html>
