<!DOCTYPE html>

<html lang="en">
    <head>
        <title>Hyperbolic 12 Tones of Christmas</title>

        <!--
        Hyperbolic space, 12 tones of christmas, with webVR support. WASD + Arrows to move, space or p to play/pause.

        A websperience by Vi Hart, Andrea Hawksley, and Henry Segerman, using the hyperbolic space prototype developed at a hyperbolic webVR "hackalot" with Vi Hart, Mike Stay, Henry Segerman, Andrea Hawksley, and Andrew Lutomirski, with help from Marc ten Bosch's 4d graphics shader, Jeff Week's Curved Spaces, Mozilla's webVR framework for THREEjs, etc.

        http://vihart.com
        http://andreahawksley.com
        http://www.segerman.org/
        http://reperiendi.wordpress.com/
        https://github.com/hawksley
        http://www.geometrygames.org/CurvedSpaces/
        http://www.marctenbosch.com
        https://github.com/MozVR/vr-web-examples/tree/master/threejs-vr-boilerplate

        Music:
        https://soundcloud.com/vihartvihart/the-12-tones-of-christmas


        -->

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                background-color: #000;
                color: #fff;
                margin: 0px;
                padding: 0;
                overflow: hidden;
            }
        </style>
    </head>

    <body>
      <audio id='music' src="media/12tonesofchristmas.mp3" autoplay />
    </body>

    <script type="x-shader/x-vertex" id="vertexShader">
    // This shader moves vertices around

    // input
    uniform float time; // global time in seconds
    uniform mat4 translation; // dodecahedral
    uniform int fogType; // which type of fog to use
    uniform vec2 mousePos;
    uniform mat4 boost;


    vec3 ChooseColor( in vec3 nBase )
    {

      float r = nBase.x;
      float g = nBase.y;
      float b = nBase.z;
      float sin_a = 0.973255;
      float cos_a = 0.229727;
      float rot_r = cos_a * r + sin_a * g;
      float rot_g = -sin_a * r + cos_a * g;

      return vec3(-rot_r*0.5 + 0.5,-rot_g*0.5 + 0.5,-b*0.5 + 0.5);
    }

    // output
    varying vec3 vColor; // this shader computes the color of each vertex

    vec4 projectToHyperboloid(vec4 v) {
      float scaleFactor = sqrt(v.w * v.w - v.x * v.x - v.y * v.y - v.z * v.z);

      vec4 result;
      result.x = v.x / scaleFactor;
      result.y = v.y / scaleFactor;
      result.z = v.z / scaleFactor;
      result.w = v.w / scaleFactor;
      return result;
    }

    // this gets called once per vertex of the monkey mesh (and 8 times since there are 8 monkeys)
    void main()
    {
      // base position
      // turn a 3D position of a monkey into a 4D position by adding a 1 as the w component then normalizing To get onto the unit 3-sphere
      vec4 p = projectToHyperboloid( vec4(position.zyx / 1.3, 1.0) );
      p = boost * translation * p;

      // this is the normal to the point
      // same concept as for the position, but we add a 0 as the w component
      // vec4 n3sphere = vec4( normal.zyx, 0.0);

      // compute the color from the normal
      vColor = ChooseColor(-normal.zyx);

      // take the final 3D position and project it onto the screen
      // p.x /= p.w;
      // p.y /= p.w;
      // p.z /= p.w;
      // p.w /= p.w;

      gl_Position = projectionMatrix * modelViewMatrix * p; //vec4( pos3 + vec3(0.0,-0.6,-1.5), 1.0 );

      // do fog
      if ( fogType == 1 )
      {
        // ramp fog
        // compute distance to camera from 0 to 1
        float zz = gl_Position.z / gl_Position.w;
        // go from 1 to 0 instead (0 is furthest and 1 is where the camera is )
        // ( note that the computed distance is not linear )
        float fogScale = 1. - zz;
        // anything closer than 0.1 gets regular color
        if ( fogScale > 0.1 )
        fogScale = 1.0;
        // everything else ramps from 0 to 1
        else
        fogScale = fogScale / 0.1;
        // mutliply color by this value to make it go to black
        vColor *= fogScale;
      }
      else if ( fogType == 2 )
      {
        // near fog
        float zz = gl_Position.z / gl_Position.w;
        // go from 1 to 0, and make the curve less straight
        float fogScale = pow( 1. - zz, 0.7 );
        // everything closer than 0.2 gets regular color
        // but everything else stays the same, creating a discontinuity
        if ( fogScale > 0.2 ) fogScale = 1.0;
        // mutliply color by this value to make it go to black
        vColor *= fogScale;
      } else if (fogType == 3 ){
        vColor.r *= mousePos.x/1000.;
        vColor.g *= mousePos.y/1000.;
        vColor.b *= abs(1. - (mousePos.x + mousePos.y)/1000.);
      }

    }
  </script>

  <script type="x-shader/x-vertex" id="fragmentShader">
    // this gets called once per pixel
    varying vec3 vColor;
    void main()
    {
      // just use the color we computed and assign it to this pixel
      gl_FragColor = vec4( vColor, 1. );
    }
  </script>

    <!--
    three.js 3d library
    -->
    <script src="js/three.min.js"></script>

    <!--
    library for fast quaternion rotation
    -->
    <script src="lib/gl-matrix.js"></script>

    <!--
    VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
     -->
    <script src="js/VRControls.js"></script>

    <!--
    VREffect.js handles stereo camera setup and rendering.
    -->
    <script src="js/VREffect.js"></script>

    <script src="js/loaders/OBJLoader.js"></script>
    <script src="js/dodec_no_id.js"></script>

    <script src="js/twelve.js" type="text/javascript" id="mainCode"></script>
    <script src="js/twelveControls.js" type="text/javascript"></script>
</html>
